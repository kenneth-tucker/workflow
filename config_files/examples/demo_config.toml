# An example config file, demonstrating the TOML syntax
# for defining an experiment to be run by Workflow.
# The setup is flexible allowing for the researcher to run
# single steps by entering their part names manually,
# or for more complex automated flows of common
# experimental tasks. This file has a lot of annotations
# to help explain in detail.
#
# See https://toml.io/en/ for more information.



# Top-level experiment variables table
[experiment]

# experiment.name is required and should use
# snake_case for easier name handling.
name = "my_demo_experiment"

# experiment.out_dir is required and should
# be a relative or absolute path in your file
# system. The output data for a particular
# run of an experiment will be
# '<experiment.out_dir>/<experiment.name>/<run_###>'.
out_dir = "my_results/examples"

# experiment.part_types_py is optional, if you want
# to override the default part_types dictionary
# (which is located in workflow/part_types/part_types.py)
# with something else. In this example we comment
# it out.
# part_types_py = "path/to/part/types/py/file"

# experiment.start is optional, if you want to
# have Workflow start running a particular part
# of the experiment automatically. If it is not
# provided then Workflow will start in a manual
# mode, where the researcher enters the name of the
# part of the experiment they want to run first.
# The manual mode is useful for ad-hoc experiments
# or for experiments with lots of distinct and
# disconnected parts. In this example we start the
# experiment automatically at the part called
# greeting, which is defined by the table
# [flow.greeting] below.
start = "greeting"



# Any experiment data you want to initialize
# when the experiment starts. Any uninitialized
# variables will be assumed to be None until they
# are assigned a value in the experiment. Each value
# must be a literal constant that is valid TOML 
# (e.g. 5, "Hello", ["a", "b", "c"] etc.). For
# initializing more complicated objects or custom
# data types, you can create your own Step type in
# Python that constructs those and assigns them to
# data variables. You then specify the name of that
# init step in the 'experiment.start' above.
[initial_values]
intro = "Hello"
researcher = "Bob"



# The rest of the config file is defining the 'parts'
# of the experiment. Each part has a table that uses
# dot notation naming and MUST start with 'flow'.
# Nested parts have a format like 
# '[flow.subflow_1.subflow_2.my_step]'.


[flow.greeting]
# The type name must match the naming in the part_types
# dictionary structure in your part_types.py file.
type_name = "steps.utils.terminal"

# The configuration values passed in at experiment
# setup, when the part is constructed. Each config
# must be a literal constant that is valid TOML 
# (e.g. 5, "Hello", etc.). You will need to use an
# init step (see initial_values description above) to
# create complex data objects and use them as inputs
# instead of as config.
config_values = {
    prompt = "{intro} {researcher}!"
}

# input_names and output_names must be name
# mapping dictionaries from argument name to
# experiment data name, of the form:
# input_names = {
#     input_x = "experiment_variable_x",
#     input_y = "experiment_variable_y",
#     ...
# }
#
# output_names = {
#     output_1 = "experiment_variable_1",
#     output_2 = "experiment_variable_2",
#     ...
# }
#
# You CANNOT assign literal values, only names.
#
# In this example, the terminal does not use an
# input_names or output_names mapping because it is
# just a simple utility. However, it is best practice
# for complex and domain-specific parts to define
# input_names and output_names name mapping so that
# the researcher can name things how they want in
# the config file and without having to worry about any
# naming collisions between different parts.
# input_names = {}
# output_names = {}

# Optional name of part to run after this
# step is done. If not provided then the researcher is
# prompted for what to do next. If the step were
# to throw an exception, we would also prompt the
# researcher about what to do next. In this example, we
# want to go to the menu step next. Unfortunately,
# TOML does not keep the file order when parsed
# into a dict so we have to specify what is next
# explicitly.
next_part = "menu"


[flow.menu]
type_name = "steps/utils/terminal"
config_values = {
    prompt = "Enter 1 to change your name\nEnter 2 for calculator\nEnter 3 for manual control\nEnter 4 to quit",
    enter = "int",
    to = "menu_option"
}
next_part = "select_option"


[flow.select_option]
type_name = "decisions/condition"
config_values = {
    statements = [
        "option_1 if {menu_option} == 1",
        "option_2 if {menu_option} == 2",
        "option_3 if {menu_option} == 3",
        "option_4 if {menu_option} == 4",
        "else try_again"
    ]
}
next_part = {
    option_1 = "name_change",
    option_2 = "calculator",
    # option_3 assumed None since absent   
    option_4 = "done",
    try_again = "menu"
}


[flow.name_change]
type_name = "steps/utils/terminal"
config_values = {
    prompt = "Enter your new name",
    enter = "str",
    to = "researcher"
}
next_part = "greeting"

